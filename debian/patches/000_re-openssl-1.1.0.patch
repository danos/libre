Description: Compile re with OpenSSL 1.1.0
 This patch is by upstream to allow compilation of re with OpenSSL
 1.1.0.
Author: Alfred E. Heggestad" <aeh@db.org>
Origin: upstream
Bug-Debian: https://bugs.debian.org/828411
Last-Update: 2016-06-26

--- libre-0.4.16.orig/src/aes/openssl/aes.c
+++ libre-0.4.16/src/aes/openssl/aes.c
@@ -17,7 +17,11 @@
 
 
 struct aes {
+#if OPENSSL_VERSION_NUMBER >= 0x10100000L
+	EVP_CIPHER_CTX *ctx;
+#else
 	EVP_CIPHER_CTX ctx;
+#endif
 };
 
 
@@ -25,7 +29,12 @@ static void destructor(void *arg)
 {
 	struct aes *st = arg;
 
+#if OPENSSL_VERSION_NUMBER >= 0x10100000L
+	if (st->ctx)
+		EVP_CIPHER_CTX_free(st->ctx);
+#else
 	EVP_CIPHER_CTX_cleanup(&st->ctx);
+#endif
 }
 
 
@@ -47,7 +56,17 @@ int aes_alloc(struct aes **aesp, enum ae
 	if (!st)
 		return ENOMEM;
 
+#if OPENSSL_VERSION_NUMBER >= 0x10100000L
+	st->ctx = EVP_CIPHER_CTX_new();
+	if (!st->ctx) {
+		ERR_clear_error();
+		err = ENOMEM;
+		goto out;
+	}
+
+#else
 	EVP_CIPHER_CTX_init(&st->ctx);
+#endif
 
 	switch (key_bits) {
 
@@ -60,7 +79,11 @@ int aes_alloc(struct aes **aesp, enum ae
 		goto out;
 	}
 
+#if OPENSSL_VERSION_NUMBER >= 0x10100000L
+	r = EVP_EncryptInit_ex(st->ctx, cipher, NULL, key, iv);
+#else
 	r = EVP_EncryptInit_ex(&st->ctx, cipher, NULL, key, iv);
+#endif
 	if (!r) {
 		ERR_clear_error();
 		err = EPROTO;
@@ -83,7 +106,11 @@ void aes_set_iv(struct aes *aes, const u
 	if (!aes || !iv)
 		return;
 
+#if OPENSSL_VERSION_NUMBER >= 0x10100000L
+	r = EVP_EncryptInit_ex(aes->ctx, NULL, NULL, NULL, iv);
+#else
 	r = EVP_EncryptInit_ex(&aes->ctx, NULL, NULL, NULL, iv);
+#endif
 	if (!r)
 		ERR_clear_error();
 }
@@ -96,10 +123,17 @@ int aes_encr(struct aes *aes, uint8_t *o
 	if (!aes || !out || !in)
 		return EINVAL;
 
+#if OPENSSL_VERSION_NUMBER >= 0x10100000L
+	if (!EVP_EncryptUpdate(aes->ctx, out, &c_len, in, (int)len)) {
+		ERR_clear_error();
+		return EPROTO;
+	}
+#else
 	if (!EVP_EncryptUpdate(&aes->ctx, out, &c_len, in, (int)len)) {
 		ERR_clear_error();
 		return EPROTO;
 	}
+#endif
 
 	return 0;
 }
--- libre-0.4.16.orig/src/hmac/openssl/hmac.c
+++ libre-0.4.16/src/hmac/openssl/hmac.c
@@ -12,7 +12,11 @@
 
 
 struct hmac {
+#if OPENSSL_VERSION_NUMBER >= 0x10100000L
+	HMAC_CTX *ctx;
+#else
 	HMAC_CTX ctx;
+#endif
 };
 
 
@@ -20,7 +24,12 @@ static void destructor(void *arg)
 {
 	struct hmac *hmac = arg;
 
+#if OPENSSL_VERSION_NUMBER >= 0x10100000L
+	if (hmac->ctx)
+		HMAC_CTX_free(hmac->ctx);
+#else
 	HMAC_CTX_cleanup(&hmac->ctx);
+#endif
 }
 
 
@@ -52,9 +61,25 @@ int hmac_create(struct hmac **hmacp, enu
 	if (!hmac)
 		return ENOMEM;
 
+#if OPENSSL_VERSION_NUMBER >= 0x10100000L
+	hmac->ctx = HMAC_CTX_new();
+	if (!hmac->ctx) {
+		ERR_clear_error();
+		err = ENOMEM;
+		goto out;
+	}
+#else
 	HMAC_CTX_init(&hmac->ctx);
+#endif
+
+#if OPENSSL_VERSION_NUMBER >= 0x10100000L
+
+	if (!HMAC_Init_ex(hmac->ctx, key, (int)key_len, evp, NULL)) {
+		ERR_clear_error();
+		err = EPROTO;
+	}
 
-#if (OPENSSL_VERSION_NUMBER >= 0x00909000)
+#elif (OPENSSL_VERSION_NUMBER >= 0x00909000)
 	if (!HMAC_Init_ex(&hmac->ctx, key, (int)key_len, evp, NULL)) {
 		ERR_clear_error();
 		err = EPROTO;
@@ -63,6 +88,9 @@ int hmac_create(struct hmac **hmacp, enu
 	HMAC_Init_ex(&hmac->ctx, key, (int)key_len, evp, NULL);
 #endif
 
+#if OPENSSL_VERSION_NUMBER >= 0x10100000L
+ out:
+#endif
 	if (err)
 		mem_deref(hmac);
 	else
@@ -80,7 +108,23 @@ int hmac_digest(struct hmac *hmac, uint8
 	if (!hmac || !md || !md_len || !data || !data_len)
 		return EINVAL;
 
-#if (OPENSSL_VERSION_NUMBER >= 0x00909000)
+#if OPENSSL_VERSION_NUMBER >= 0x10100000L
+	/* the HMAC context must be reset here */
+	if (!HMAC_Init_ex(hmac->ctx, 0, 0, 0, NULL))
+		goto error;
+
+	if (!HMAC_Update(hmac->ctx, data, (int)data_len))
+		goto error;
+	if (!HMAC_Final(hmac->ctx, md, &len))
+		goto error;
+
+	return 0;
+
+ error:
+	ERR_clear_error();
+	return EPROTO;
+
+#elif (OPENSSL_VERSION_NUMBER >= 0x00909000)
 	/* the HMAC context must be reset here */
 	if (!HMAC_Init_ex(&hmac->ctx, 0, 0, 0, NULL))
 		goto error;
--- libre-0.4.16.orig/src/main/openssl.c
+++ libre-0.4.16/src/main/openssl.c
@@ -23,6 +23,9 @@
 static pthread_mutex_t *lockv;
 
 
+#if OPENSSL_VERSION_NUMBER < 0x10100000L
+
+
 static inline unsigned long threadid(void)
 {
 #if defined (DARWIN) || defined (FREEBSD) || defined (OPENBSD) || \
@@ -47,6 +50,10 @@ static unsigned long threadid_handler(vo
 #endif
 
 
+#endif  /* OPENSSL_VERSION_NUMBER */
+
+
+#if OPENSSL_VERSION_NUMBER < 0x10100000L
 static void locking_handler(int mode, int type, const char *file, int line)
 {
 	(void)file;
@@ -57,10 +64,13 @@ static void locking_handler(int mode, in
 	else
 		(void)pthread_mutex_unlock(&lockv[type]);
 }
+#endif
+
 
 #endif
 
 
+#if OPENSSL_VERSION_NUMBER < 0x10100000L
 static struct CRYPTO_dynlock_value *dynlock_create_handler(const char *file,
 							   int line)
 {
@@ -97,6 +107,7 @@ static void dynlock_destroy_handler(stru
 
 	mem_deref(l);
 }
+#endif
 
 
 #ifdef SIGPIPE
--- libre-0.4.16.orig/src/tls/openssl/tls.h
+++ libre-0.4.16/src/tls/openssl/tls.h
@@ -5,6 +5,12 @@
  */
 
 
+#if OPENSSL_VERSION_NUMBER >= 0x10100000L
+#define SSL_state SSL_get_state
+#define SSL_ST_OK TLS_ST_OK
+#endif
+
+
 struct tls {
 	SSL_CTX *ctx;
 	X509 *cert;
--- libre-0.4.16.orig/src/tls/openssl/tls_tcp.c
+++ libre-0.4.16/src/tls/openssl/tls_tcp.c
@@ -33,6 +33,9 @@ struct tls_conn {
 	struct tcp_conn *tcp;
 	bool active;
 	bool up;
+#if OPENSSL_VERSION_NUMBER >= 0x10100000L
+	BIO_METHOD *method;  /* XXX: can move to a shared state? */
+#endif
 };
 
 
@@ -49,15 +52,26 @@ static void destructor(void *arg)
 	}
 	mem_deref(tc->th);
 	mem_deref(tc->tcp);
+
+#if OPENSSL_VERSION_NUMBER >= 0x10100000L
+	if (tc->method)
+		BIO_meth_free(tc->method);
+#endif
 }
 
 
 static int bio_create(BIO *b)
 {
+#if OPENSSL_VERSION_NUMBER >= 0x10100000L
+	BIO_set_init(b, 1);
+	BIO_set_data(b, NULL);
+	BIO_set_flags(b, 0);
+#else
 	b->init  = 1;
 	b->num   = 0;
 	b->ptr   = NULL;
 	b->flags = 0;
+#endif
 
 	return 1;
 }
@@ -68,9 +82,15 @@ static int bio_destroy(BIO *b)
 	if (!b)
 		return 0;
 
+#if OPENSSL_VERSION_NUMBER >= 0x10100000L
+	BIO_set_init(b, 0);
+	BIO_set_data(b, NULL);
+	BIO_set_flags(b, 0);
+#else
 	b->ptr   = NULL;
 	b->init  = 0;
 	b->flags = 0;
+#endif
 
 	return 1;
 }
@@ -78,7 +98,11 @@ static int bio_destroy(BIO *b)
 
 static int bio_write(BIO *b, const char *buf, int len)
 {
+#if OPENSSL_VERSION_NUMBER >= 0x10100000L
+	struct tls_conn *tc = BIO_get_data(b);
+#else
 	struct tls_conn *tc = b->ptr;
+#endif
 	struct mbuf mb;
 	int err;
 
@@ -109,6 +133,7 @@ static long bio_ctrl(BIO *b, int cmd, lo
 }
 
 
+#if OPENSSL_VERSION_NUMBER < 0x10100000L
 static struct bio_method_st bio_tcp_send = {
 	BIO_TYPE_SOURCE_SINK,
 	"tcp_send",
@@ -121,6 +146,7 @@ static struct bio_method_st bio_tcp_send
 	bio_destroy,
 	0
 };
+#endif
 
 
 static int tls_connect(struct tls_conn *tc)
@@ -346,7 +372,27 @@ int tls_start_tcp(struct tls_conn **ptc,
 		goto out;
 	}
 
+#if OPENSSL_VERSION_NUMBER >= 0x10100000L
+	tc->method = BIO_meth_new(BIO_TYPE_SOURCE_SINK, "tcp_send");
+	if (!tc->method) {
+		DEBUG_WARNING("alloc: BIO_meth_new() failed\n");
+		ERR_clear_error();
+		BIO_free(tc->sbio_in);
+		goto out;
+	}
+
+	BIO_meth_set_write(tc->method, bio_write);
+	BIO_meth_set_ctrl(tc->method, bio_ctrl);
+	BIO_meth_set_create(tc->method, bio_create);
+	BIO_meth_set_destroy(tc->method, bio_destroy);
+#endif
+
+
+#if OPENSSL_VERSION_NUMBER >= 0x10100000L
+	tc->sbio_out = BIO_new(tc->method);
+#else
 	tc->sbio_out = BIO_new(&bio_tcp_send);
+#endif
 	if (!tc->sbio_out) {
 		DEBUG_WARNING("alloc: BIO_new_socket() failed\n");
 		ERR_clear_error();
@@ -354,7 +400,11 @@ int tls_start_tcp(struct tls_conn **ptc,
 		goto out;
 	}
 
+#if OPENSSL_VERSION_NUMBER >= 0x10100000L
+	BIO_set_data(tc->sbio_out, tc);
+#else
 	tc->sbio_out->ptr = tc;
+#endif
 
 	SSL_set_bio(tc->ssl, tc->sbio_in, tc->sbio_out);
 
--- libre-0.4.16.orig/src/tls/openssl/tls_udp.c
+++ libre-0.4.16/src/tls/openssl/tls_udp.c
@@ -3,6 +3,9 @@
  *
  * Copyright (C) 2010 Creytiv.com
  */
+
+#include <sys/time.h>
+
 #define OPENSSL_NO_KRB5 1
 #include <openssl/ssl.h>
 #include <openssl/err.h>
@@ -58,15 +61,24 @@ struct tls_conn {
 	void *arg;
 	bool active;
 	bool up;
+#if OPENSSL_VERSION_NUMBER >= 0x10100000L
+	BIO_METHOD *method;  /* XXX: can move to a shared state? */
+#endif
 };
 
 
 static int bio_create(BIO *b)
 {
+#if OPENSSL_VERSION_NUMBER >= 0x10100000L
+	BIO_set_init(b, 1);
+	BIO_set_data(b, NULL);
+	BIO_set_flags(b, 0);
+#else
 	b->init  = 1;
 	b->num   = 0;
 	b->ptr   = NULL;
 	b->flags = 0;
+#endif
 
 	return 1;
 }
@@ -77,9 +89,15 @@ static int bio_destroy(BIO *b)
 	if (!b)
 		return 0;
 
+#if OPENSSL_VERSION_NUMBER >= 0x10100000L
+	BIO_set_init(b, 0);
+	BIO_set_data(b, NULL);
+	BIO_set_flags(b, 0);
+#else
 	b->ptr   = NULL;
 	b->init  = 0;
 	b->flags = 0;
+#endif
 
 	return 1;
 }
@@ -87,7 +105,11 @@ static int bio_destroy(BIO *b)
 
 static int bio_write(BIO *b, const char *buf, int len)
 {
+#if OPENSSL_VERSION_NUMBER >= 0x10100000L
+	struct tls_conn *tc = BIO_get_data(b);
+#else
 	struct tls_conn *tc = b->ptr;
+#endif
 	struct mbuf *mb;
 	enum {SPACE = 4};
 	int err;
@@ -110,7 +132,11 @@ static int bio_write(BIO *b, const char
 
 static long bio_ctrl(BIO *b, int cmd, long num, void *ptr)
 {
+#if OPENSSL_VERSION_NUMBER >= 0x10100000L
+	struct tls_conn *tc = BIO_get_data(b);
+#else
 	struct tls_conn *tc = b->ptr;
+#endif
 	(void)num;
 	(void)ptr;
 
@@ -135,6 +161,7 @@ static long bio_ctrl(BIO *b, int cmd, lo
 }
 
 
+#if OPENSSL_VERSION_NUMBER < 0x10100000L
 static struct bio_method_st bio_udp_send = {
 	BIO_TYPE_SOURCE_SINK,
 	"udp_send",
@@ -147,6 +174,7 @@ static struct bio_method_st bio_udp_send
 	bio_destroy,
 	0
 };
+#endif
 
 
 static void tls_close(struct tls_conn *tc)
@@ -173,6 +201,11 @@ static void conn_destructor(void *arg)
 	tmr_cancel(&tc->tmr);
 	tls_close(tc);
 	mem_deref(tc->sock);
+
+#if OPENSSL_VERSION_NUMBER >= 0x10100000L
+	if (tc->method)
+		BIO_meth_free(tc->method);
+#endif
 }
 
 
@@ -442,7 +475,26 @@ static int conn_alloc(struct tls_conn **
 		goto out;
 	}
 
+#if OPENSSL_VERSION_NUMBER >= 0x10100000L
+	tc->method = BIO_meth_new(BIO_TYPE_SOURCE_SINK, "udp_send");
+	if (!tc->method) {
+		DEBUG_WARNING("alloc: BIO_meth_new() failed\n");
+		ERR_clear_error();
+		BIO_free(tc->sbio_in);
+		goto out;
+	}
+
+	BIO_meth_set_write(tc->method, bio_write);
+	BIO_meth_set_ctrl(tc->method, bio_ctrl);
+	BIO_meth_set_create(tc->method, bio_create);
+	BIO_meth_set_destroy(tc->method, bio_destroy);
+#endif
+
+#if OPENSSL_VERSION_NUMBER >= 0x10100000L
+	tc->sbio_out = BIO_new(tc->method);
+#else
 	tc->sbio_out = BIO_new(&bio_udp_send);
+#endif
 	if (!tc->sbio_out) {
 		ERR_clear_error();
 		BIO_free(tc->sbio_in);
@@ -450,7 +502,11 @@ static int conn_alloc(struct tls_conn **
 		goto out;
 	}
 
+#if OPENSSL_VERSION_NUMBER >= 0x10100000L
+	BIO_set_data(tc->sbio_out, tc);
+#else
 	tc->sbio_out->ptr = tc;
+#endif
 
 	SSL_set_bio(tc->ssl, tc->sbio_in, tc->sbio_out);
 
